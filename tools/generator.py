import argparse
import json
import os
import datetime

def file_header(version, comment_char="//"):
    return f"""{comment_char} ----------------------------------------------------------------------------
{comment_char} Kinisi motr controller commands.
{comment_char} This file is auto generated by the commands generator from JSON file.
{comment_char} Do not edit this file manually.
{comment_char} Timestamp: { datetime.datetime.now().strftime("%Y-%m-%d %H:%M:00") }
{comment_char} Version: {version}
{comment_char} ----------------------------------------------------------------------------\n\n"""

# Generates a header file from the commands JSON file
def generate_kinisi_h_file(commands_data):
    # Create commands definitions
    definitions = "// Commands"
    for cmd in commands_data['commands']:
        definitions +=  f"// {cmd['description']}\n"
        definitions += f"#define {cmd['command']} {cmd['code']}\n\n"

    kinisi_controller_class = "class KinisiController\n"
    kinisi_controller_class += "{\n"
    kinisi_controller_class += "public:\n"

    kinisi_controller_class += "    // Constructor\n"
    kinisi_controller_class += "    KinisiController(int address);\n\n"

    kinisi_controller_class += "    // Starts Wire library\n"
    kinisi_controller_class += "    void begin();\n\n"

    for cmd in commands_data['commands']:
        response = cmd.get('response', None)
        return_type = response['type'] if response else "void"
        kinisi_controller_class += f"    // {cmd['command']}: {cmd['description']}\n"
        func_args = ', '.join([f"{prop['type']} {prop['name']}" for prop in cmd.get('properties', [])])
        kinisi_controller_class += f"    {return_type} {cmd['command'].lower()}({func_args});\n\n"

    kinisi_controller_class += "private:\n"
    kinisi_controller_class += "    uint8_t address;\n"
    kinisi_controller_class += "};\n\n"
    
    result = file_header(commands_data['version'])
    result += "#ifndef KINISI_H\n"
    result += "#define KINISI_H\n\n"
    result += "#include \"Arduino.h\"\n"
    result += "#include \"i2cutils.h\"\n\n"
    result += definitions
    result += "\n"
    result += kinisi_controller_class
    result += "#endif // KINISI_H\n"

    return result

# Generates a header file from the commands JSON file
def generate_kinisi_cpp_file(commands_data):
    # Generate constructor
    class_methods = "// Constructor\n"
    class_methods += "KinisiController::KinisiController(int address)\n"
    class_methods += "{\n"
    class_methods += "    this->address = address;\n"
    class_methods += "}\n\n"

    # Generate begin method
    class_methods += "// Begin\n"
    class_methods += "void KinisiController::begin()\n"
    class_methods += "{\n"
    class_methods += "    Wire.begin();\n"
    class_methods += "}\n\n"

    # Generate methods
    for cmd in commands_data['commands']:
        properties = cmd.get('properties', [])
        class_methods += f"// {cmd['command']}: {cmd['description']}\n"
        func_args = ', '.join([f"{prop['type']} {prop['name']}" for prop in properties])

        # Method return type
        response = cmd.get('response', None)
        return_type = response['type'] if response else "void"

        # Method body
        class_methods += f"{return_type} KinisiController::{cmd['command'].lower()}({func_args})\n"
        class_methods += "{\n"
        class_methods += f"    unsigned char cmd[] = {{{cmd['command']}{', ' if len(properties) > 0 else ''}{', '.join([prop['name'] for prop in properties])}}};\n"
        class_methods += f"    SendMessage(this->address, cmd, sizeof(cmd));\n"

        if response:
            class_methods += f"    uint8_t response[sizeof({response['type']})] = {{0}};\n"
            class_methods += f"    ReceiveResponse(this->address, response, sizeof({response['type']}));\n"
            class_methods += f"    return *({response['type']}*)response;\n"

        class_methods += "}\n\n"

    # Put everything together
    result = file_header(commands_data['version'])
    result += "#include \"kinisi.h\"\n"
    result += "#include \"Wire.h\"\n\n"
    result += class_methods
    return result

# Generate a keywords.txt file from the commands JSON file
def generate_keywords_txt_file(commands_data):
    lines = "#######################################\n"
    lines +=  "# Syntax Coloring Map For VsRealityKinisi\n"
    lines += "#######################################\n\n"

    lines += "#######################################\n"
    lines += "# Class (KEYWORD1)\n"
    lines += "#######################################\n\n"

    lines += "KinisiController	KEYWORD1\n\n"

    lines += "#######################################\n"
    lines += "# Methods and Functions (KEYWORD2)\n"
    lines += "#######################################\n\n"

    for cmd in commands_data['commands']:
        lines += f"{cmd['command'].lower()}	KEYWORD2\n\n"

    lines += "#######################################\n"
    lines += "# Constants (LITERAL1)\n"
    lines += "#######################################\n\n"
    return lines

def main():
    parser = argparse.ArgumentParser(description='Generate code from command definitions in JSON.')
    parser.add_argument('input_json_path', type=str, help='Path to the input JSON file containing command definitions.')
    parser.add_argument('output_path', type=str, help='Path to the output directory.')
    args = parser.parse_args()

    # Check if the input JSON file exists
    if not os.path.exists(args.input_json_path):
        print(f"Error: Input JSON file '{args.input_json_path}' not found.")
        return

    try:
        commands_data_file = open(args.input_json_path, 'r')
        commands_data = json.load(commands_data_file)

        kinisi_h = generate_kinisi_h_file(commands_data)

        kinisi_h_file = open(f'{args.output_path}/kinisi.h', 'w')
        kinisi_h_file.write(kinisi_h)

        kinisi_cpp = generate_kinisi_cpp_file(commands_data)
        kinisi_cpp_file = open(f'{args.output_path}/kinisi.cpp', 'w')
        kinisi_cpp_file.write(kinisi_cpp)

        keywords_txt = generate_keywords_txt_file(commands_data)
        keywords_txt_file = open(f'{args.output_path}/keywords.txt', 'w')
        keywords_txt_file.write(keywords_txt)

    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return

if __name__ == "__main__":
    main()
